!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).SmartGallery=e()}(this,function(){"use strict";return class{constructor(t,e={}){if(this.container="string"==typeof t?document.querySelector(t):t,!this.container)throw new Error("SmartGallery: Container not found.");this.options=Object.assign({layout:"justified",gap:10,targetRowHeight:300,lastRowBehavior:"left",columnWidth:300,columns:"auto",className:"",itemClassName:"sg-item",virtualize:!0,buffer:500,placeholderColor:"#eee",renderItem:null,onItemClick:null},e),this.items=[],this.geometry=[],this.renderedIndices=new Set,this.mountedItemElements=new Map,this.topSortedGeometryIndices=[],this.topSortedStarts=[],this.maxGeometryHeight=0,this.currentVisibleStartPos=-1,this.currentVisibleEndPos=-1,this.resizeObserver=null,this.scrollHandler=null,this.scrollContainer=window,this.isResizing=!1,this.lastObservedWidth=this.container.clientWidth,this._init()}_init(){let t;this.container.style.position="relative",this.container.classList.add("smart-gallery"),this.options.className&&this.container.classList.add(this.options.className),this.resizeObserver=new ResizeObserver(()=>{if(this.isResizing)return;const e=this.container.clientWidth;Math.abs(e-this.lastObservedWidth)<1||(this.lastObservedWidth=e,clearTimeout(t),t=setTimeout(()=>{this.render()},100))}),this.resizeObserver.observe(this.container),this.options.virtualize&&(this.scrollContainer=this._getScrollParent(this.container),this.scrollHandler=this._throttle(this._handleScroll.bind(this),50),this.scrollContainer.addEventListener("scroll",this.scrollHandler,{passive:!0}))}_getScrollParent(t){let e=t.parentElement;for(;e;){const t=window.getComputedStyle(e).overflowY;if(("auto"===t||"scroll"===t||"overlay"===t)&&e.scrollHeight>e.clientHeight)return e;e=e.parentElement}return window}addItems(t){const e=t.map(t=>{let e=Number(t.aspectRatio);if(!Number.isFinite(e)||e<=0){const i=Number(t.width),s=Number(t.height);Number.isFinite(i)&&Number.isFinite(s)&&s>0&&(e=i/s)}return(!Number.isFinite(e)||e<=0)&&(e=1),{...t,aspectRatio:e}});this.items=[...this.items,...e]}render(){if(this.container&&0!==this.items.length){this.isResizing=!0;try{const t=this.container.clientWidth;this.lastObservedWidth=t;const{layout:e}=this.options;let i,s=0;this.renderedIndices.clear(),this.mountedItemElements.clear(),this.topSortedGeometryIndices=[],this.topSortedStarts=[],this.maxGeometryHeight=0,this.currentVisibleStartPos=-1,this.currentVisibleEndPos=-1,this.container.innerHTML="",this.geometry=[],"justified"===e?i=this._computeJustifiedLayout(this.items,t,this.options):"masonry"===e?i=this._computeMasonryLayout(this.items,t,this.options):"grid"===e&&(i=this._computeGridLayout(this.items,t,this.options)),this.geometry=i.boxes.map((t,e)=>({...t,itemIndex:e})),s=i.containerHeight,this._buildVisibleIndex(),this.container.style.height=`${s}px`,this._updateVisibleItems()}finally{this.isResizing=!1}}}_buildVisibleIndex(){const t=this.geometry.map((t,e)=>({idx:e,top:t.top})).sort((t,e)=>t.top-e.top);this.topSortedGeometryIndices=new Array(t.length),this.topSortedStarts=new Array(t.length);let e=0;for(let i=0;i<t.length;i++){const s=t[i];this.topSortedGeometryIndices[i]=s.idx,this.topSortedStarts[i]=s.top;const o=this.geometry[s.idx].height;o>e&&(e=o)}this.maxGeometryHeight=e}_lowerBound(t,e){let i=0,s=t.length;for(;i<s;){const o=i+s>>1;t[o]<e?i=o+1:s=o}return i}_mountRangeByPos(t,e){if(t<0||e<0||e<t)return;const i=document.createDocumentFragment();for(let s=t;s<=e;s++){const t=this.topSortedGeometryIndices[s],e=this.geometry[t].itemIndex;this.renderedIndices.has(e)||(this._mountItem(this.geometry[t],i),this.renderedIndices.add(e))}this.container.appendChild(i)}_unmountRangeByPos(t,e){if(!(t<0||e<0||e<t))for(let i=t;i<=e;i++){const t=this.topSortedGeometryIndices[i],e=this.geometry[t].itemIndex;this.renderedIndices.has(e)&&(this._unmountItem(e),this.renderedIndices.delete(e))}}_updateVisibleItems(){if(!this.options.virtualize){const t=document.createDocumentFragment();for(let e=0;e<this.geometry.length;e++){const i=this.geometry[e],s=i.itemIndex;this.renderedIndices.has(s)||(this._mountItem(i,t),this.renderedIndices.add(s))}return void this.container.appendChild(t)}const t=this.options.buffer;let e=0,i=0,s=0;if(this.scrollContainer===window){e=window.scrollY,i=window.innerHeight;s=this.container.getBoundingClientRect().top+e}else{e=this.scrollContainer.scrollTop,i=this.scrollContainer.clientHeight;const t=this.container.getBoundingClientRect(),o=this.scrollContainer.getBoundingClientRect();s=t.top-o.top+e}const o=Math.max(0,e-s-t),n=e-s+i+t;let r=-1,h=-1;if(this.topSortedGeometryIndices.length>0){const t=Math.max(0,o-this.maxGeometryHeight);let e=this._lowerBound(this.topSortedStarts,t);for(;e<this.topSortedGeometryIndices.length;){const t=this.topSortedGeometryIndices[e],i=this.geometry[t];if(i.top>=n)break;i.top+i.height>o&&(-1===r&&(r=e),h=e),e++}}const l=this.currentVisibleStartPos,a=this.currentVisibleEndPos;-1===r?this._unmountRangeByPos(l,a):-1===l?this._mountRangeByPos(r,h):(r<l&&this._mountRangeByPos(r,Math.min(l-1,h)),h>a&&this._mountRangeByPos(Math.max(a+1,r),h),l<r&&this._unmountRangeByPos(l,Math.min(r-1,a)),a>h&&this._unmountRangeByPos(Math.max(h+1,l),a)),this.currentVisibleStartPos=r,this.currentVisibleEndPos=h}_mountItem(t,e=this.container){const i=t.itemIndex,s=this.items[i],o=document.createElement("div");if(o.className=this.options.itemClassName,o.id=`sg-item-${i}`,o.style.position="absolute",o.style.left=`${t.left}px`,o.style.top=`${t.top}px`,o.style.width=`${t.width}px`,o.style.height=`${t.height}px`,this.options.renderItem)o.appendChild(this.options.renderItem(s,i));else{o.style.backgroundColor=s.placeholderColor||this.options.placeholderColor;const t=document.createElement("img");t.src=s.src,t.style.width="100%",t.style.height="100%",t.style.objectFit="cover",t.style.display="block",t.style.opacity="0",t.style.transition="opacity 0.3s",t.loading="lazy",t.onload=()=>{t.style.opacity="1"},o.appendChild(t)}o.addEventListener("click",t=>{this.options.onItemClick&&this.options.onItemClick({index:i,itemData:s,originalEvent:t})}),e.appendChild(o),this.mountedItemElements.set(i,o)}_unmountItem(t){const e=this.mountedItemElements.get(t);e&&(e.remove(),this.mountedItemElements.delete(t))}_handleScroll(){this.isResizing||requestAnimationFrame(()=>this._updateVisibleItems())}_throttle(t,e){let i;return function(){const s=arguments,o=this;i||(t.apply(o,s),i=!0,setTimeout(()=>i=!1,e))}}_applyPixelAlignment(t){for(let e=0;e<t.length;e++){const i=t[e];i.left=Math.round(i.left),i.top=Math.round(i.top),i.width=Math.max(1,Math.round(i.width)),i.height=Math.max(1,Math.round(i.height))}}_computeJustifiedLayout(t,e,i){const{targetRowHeight:s,gap:o,lastRowBehavior:n}=i,r=[];let h=0;const l=.5*s,a=t.map(t=>t.aspectRatio),c=new Map,d=(t,i,s)=>{const n=i-t+1,r=`${t}-${i}`;let h=c.get(r);if(void 0!==h)return h;return h=(e-(n-1)*o)/s,c.set(r,h),h};let m=0;for(;m<t.length;){let i=0,c=-1,u=0,p=1/0,g=m;for(;g<t.length;){i+=a[g];const t=d(m,g,i);if(t<l)break;const e=Math.abs(t-s);e<p&&(p=e,c=g,u=i),g++}if(-1!==c){const i=c===t.length-1;let l=0;const p=u,g=(c-m+1-1)*o;l=d(m,c,p);let y=0;if(i){const t=n;if("hide"===t)break;if("left"===t||"center"===t||"right"===t){const i=(e-g)/p;l=Math.min(s,i);const o=p*l+g,n=Math.max(0,e-o);"center"===t?y=n/2:"right"===t&&(y=n)}}let f=y;for(let t=m;t<=c;t++){const e=l*a[t];r.push({left:f,top:h,width:e,height:l}),f+=e+o}h+=l+o,m=c+1}else{const t=Math.min(s,e/a[m]),i=t*a[m];r.push({left:0,top:h,width:i,height:t}),h+=t+o,m++}}return this._applyPixelAlignment(r),{boxes:r,containerHeight:Math.max(0,r.length>0?h-o:0)}}_getColumnMetrics(t,e){const{gap:i,columnWidth:s,columns:o}=e;let n=0,r=0;return"auto"===o?(r=s,n=Math.floor((t+i)/(r+i)),n=Math.max(1,n),r=(t-(n-1)*i)/n):(n=o,r=(t-(n-1)*i)/n),{gap:i,colCount:n,colW:r}}_heapLess(t,e){return t.height!==e.height?t.height<e.height:t.colIndex<e.colIndex}_heapPush(t,e){t.push(e);let i=t.length-1;for(;i>0;){const e=i-1>>1;if(!this._heapLess(t[i],t[e]))break;[t[i],t[e]]=[t[e],t[i]],i=e}}_heapPop(t){if(1===t.length)return t.pop();const e=t[0];t[0]=t.pop();let i=0;for(;;){const e=2*i+1,s=e+1;let o=i;if(e<t.length&&this._heapLess(t[e],t[o])&&(o=e),s<t.length&&this._heapLess(t[s],t[o])&&(o=s),o===i)break;[t[i],t[o]]=[t[o],t[i]],i=o}return e}_computeMasonryLayout(t,e,i){const{gap:s,colCount:o,colW:n}=this._getColumnMetrics(e,i),r=[],h=[];for(let t=0;t<o;t++)this._heapPush(h,{colIndex:t,height:0});let l=0;for(let e=0;e<t.length;e++){const i=this._heapPop(h),o=i.colIndex,a=i.height,c=n/t[e].aspectRatio;r.push({left:o*(n+s),top:a,width:n,height:c});const d=a+c+s;d>l&&(l=d),this._heapPush(h,{colIndex:o,height:d})}return this._applyPixelAlignment(r),{boxes:r,containerHeight:Math.max(0,r.length>0?l-s:0)}}_computeGridLayout(t,e,i){const{gap:s,colCount:o,colW:n}=this._getColumnMetrics(e,i),r=n,h=[];for(let e=0;e<t.length;e++){const t=e%o,i=Math.floor(e/o);h.push({left:t*(n+s),top:i*(r+s),width:n,height:r})}const l=Math.ceil(t.length/o);return this._applyPixelAlignment(h),{boxes:h,containerHeight:l*(r+s)-s}}destroy(){this.resizeObserver&&this.resizeObserver.disconnect(),this.scrollHandler&&this.scrollContainer&&this.scrollContainer.removeEventListener("scroll",this.scrollHandler)}}});
